-- the block chain
each has:
	a previous bloch hash
	the hash for each transaction (? - found with the signatures and public keys from parties?)

concat these together with a +nonce+ to generate a hash with a certain number of 0s at the front
	the nonce is the only variable part - mining is the process of finding a valid nonce

when a block has been solved (a valid nonce has been found), the block is closed




-- questions
	what happens to transactions while a block is being solved? new ones would change parameters for block completion
		must be some cutoff - but what if the transactions keep coming in and the system gets backloaded?
			maybe put the transactions in a queue and remove them if they are in a solved block
			then all other miners have to discard their work and move on to the next block (they choose how many to put in their next block, but the solved blocks determine how many tx are removed from the queue)
			just hope they don't get backlogged

		=== so I guess they are just stored in a pool and only removed when a block that contains them is solved

	where exactly does the transaction id come from?

	the timestamp
		it can't change over the course of the POW or it would be basically impossible to solve a header
		so is it when the block is "made"?
		but it says the block was "solved at" on the blockchain


-- transactions
inputs are the public addresses of each party



-- mining process
(outline from here: http://bitcoin.stackexchange.com/questions/17758/number-of-transactions-per-block)
	miners select tx from memory pool for inclusion in new block (number, method, and criteria is up to miner)
	miners make a merkle tree from the tx in step #1 (i'll probably wait to implement this)
	miners make a block header with the merkle tree, prior block hash, version, timestamp, and nonce
		(how does the timestamp get decided - when they first start mining?)
		(how is the block header "made"?)
	hash the block header, if it is valid the block is completed, added to chain, and broadcast to other miners
		the valid hash becomes the prior block hash for the next block
	if it is not valid, increment the nonce and try again
		if the nonce is exhausted (tried all possible values), change another element in the blockheader and reset the nonce
			(does that mean adding/subtracting transactions?)

	completing a block rewards the miner with a bonus (free coins) (and the transaction fees from the tx?)



-- transactions







-- start with 





--- what I should do ---

make a server that allows for transfers
have accounts on the server?
users can mutually agree to exchange coins
transactions get added to a block chain
	visible on the home page
persist the keys in a db? make a wallet extension? idk
	I shouldn't put them in a db 




________ ------ Actual Outline ------ ________ 

- users/ownership -
generate private key randomly - users will store this and one will be associated with their account (not safe but who cares)

generate public key and address from the private key (also store this in mongo)

- transactions -
create signature function
	generates signature based on private key and address of recipient (?)
create validate signature function
	uses sender's public key (?) and recipient's address to validate signature
create transaction hash
emit transaction

- mining -
emit transaction hash along with transaction data to all miners (browser instances)
	store transaction and its data in each mine's storage
	on initialization of a mine, query the blockchain from the server

have miners validate transactions (? - probably put this in later)

miners choose transactions with highest tips (or randomly) and generate block header
	either merkel tree or hash all transaction hashes
	add to timestamp (when the block starts working on solving the problem? or continuously update)
	add previous block's header (all 000s if the first chain)
	start with nonce at all 0000s (--consider what to do if nonce is exhausted--)

begin POW process
	increment nonce each time
	keep track of counter (times hashed) - show it on the page (only increment in 1000s or something else big enough so it isn't ridiculous)

when valid header is found (aka the correct nonce) emit event to the server (websockets)
	server attaches block to blockchain and emits new blockchain
	server removes tx in the new block from tx repo and emits remove tx event
	miners abandon their current block and start on next one (new block's hash is now the previous hash)
	miners also remove tx that were already completed and might pick new ones

have webpage update with the data



// the blockchain

what should each block have?
	its own hash
	the previous hash
	all the tx hashes (an array of tx)





--- notes ---

bitcoin uses SHA256
Hashcash - Scrypt
SHA-2 (256)
ECDSA
POW

